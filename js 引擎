一个 进程 的运行，当然需要很多个 线程 互相配合，比如打开QQ的这个进程，可能同时有接收消息线程、传输文件线程、检测安全线程......
所以一个网页能够正常的运行
并和用户交互，也需要很多个线程之间相互配合，而其主要的一些线程，刚才在上面已经列出来了，
分类：
类别A：GUI 渲染线程

类别B：JS 引擎线程

类别C：EventLoop轮询处理线程

类别D：其他线程，有 定时器触发线程 (setTimeout)、http 异步线程、浏览器事件线程 (onclick)等等。
注意：类别A和类别B是互斥的，js语言设定js引擎与GUI引擎是互斥的，也就是说GUI引擎在渲染时会阻塞js引擎计算。原因很简单，如果在GUI渲染的时候，
js改变了dom，那么就会造成渲染不同步.。下面的讨论，就不涉及类别A了，只讨论类别B、C、D之间的关系。

类别B：
JS 引擎线程，我们把它称为 主线程 ，它是干嘛的？即运行JS代码的那个线程（不包括异步的那些代码），比如：
1 var a = 2;
2 setTimeout()
3 ajax()
4 console.log()
第1、4行代码是同步代码，直接在主线程中运行；第2、3行代码交给其他线程运行。主线程运行JS代码时，
会生成个 执行栈 ，可以处理函数的嵌套，通过出栈进栈这样，这里不做过多介绍，很多文章。消息队列（任务队列）可以理解为一个静态的队列存储结构，
非线程，只做存储，里面存的是一堆异步成功后的回调函数，肯定是先成功的异步的回调函数在队列的前面，后成功的在后面。注意：是异步成功后，
才把其回调函数扔进队列中，而不是一开始就把所有异步的回调函数扔进队列。比如setTimeout 3秒后执行一个函数，那么这个函数是在3秒后才进队列的。

类别D：JS代码中，碰到异步代码，就被放入相对应的线程中去执行，比如：
1 var a = 2;
2 setTimeout(fun A)
3 ajax(fun B)
4 console.log()
5 dom.onclick(func C)
主线程在运行这段代码时，碰到2 setTimeout(fun A)，把这行代码交给 定时器触发线程 去执行碰到3 ajax(fun B)，
把这行代码交给 http 异步线程 去执行碰到5 dom.onclick(func C) ，把这行代码交给 浏览器事件线程 去执行注意：
这几个异步代码的回调函数fun A，fun B，fun C，各自的线程都会保存着的，因为需要在未来执行啊。。。
所以，这几个线程主要干两件事：

1、执行主线程扔过来的异步代码，并执行代码

2、保存着回调函数，异步代码执行成功后，通知 EventLoop轮询处理线程 过来取相应的回调函数



类别C：
EventLoop轮询处理线程上面我们已经知道了，有3个东西
1、主线程，处理同步代码
2、类别D的线程，处理异步代码
3、消息队列，存储着异步成功后的回调函数，一个静态存储结构这里再对消息队列说一下，
其作用就是存放着未来要执行的回调函数，比如
setTimeout(() => {
console.log(1)
}, 2000)
setTimeout(() => { 
console.log(2)
}, 3000)在一开始，消息队列是空的，在2秒后，一个 () => { console.log(1) } 的函数进入队列，
在3秒后，一个 () => { console.log(2) }的函数进入队列，此时队列里有两个元素，主线程从队列头中挨个取出并执行。
到这里我们就知道了，这3个东西大概的作用、关系和流程，但是，它们3个互相怎么交流的？
这需要一个中介去专门去沟通它们3个，而这个中介，就是 EventLoop轮询处理线程既然叫轮询了，那么肯定是不断的循环的去交流和沟通


类别A：
  负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
  当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
  注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
  
  
  
macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）

每一个task会从头到尾将这个任务执行完毕，不会执行其它
浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染



microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务

也就是说，在当前task任务后，下一个task之前，在渲染之前
所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染
也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）


脚本开始执行，最先遇到setTimeout，交给浏览器去计时，达到setTimeout限制最短计时之后，把这个任务推入setTimeout队列。
遇到Promise构造函数，构造函数参数执行，输出1，调用resolve改变Promise对象的状态，然后输出2。
Promise对象调用then方法，将这个任务推入Promise任务队列。
执行console.log(3)，输出3。
调用栈为空，读取任务队列，按照 读取所有微观任务队列 -> 执行 ->
读取一个宏观任务队列 -> 执行 ->
读取所有微观任务队列 -> 执行 ->
再读取一个宏观任务队列…的顺序。
读取所有微观任务队列中的任务，执行这些任务指定的回调函数。执行then指定的回调函数，输出5（微观任务队列也具有优先级）。
最后读取到setTimeout的任务，执行回调函数，输出4。
https://segmentfault.com/img/bVXKpk?w=746&h=597






